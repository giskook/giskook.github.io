---
layout: post
title: "【译】kafka简介"
date: 2021-11-09 20:02:24+08:00
categories: work tech
---

----------------

[原文地址](https://kafka.apache.org/documentation/#introduction) 关注design部分

----------------

### 动机

设计kafka是为了处理所有的很多大公司可能会有的实时数据流。为此需要考虑相当广泛的使用场景。

应该对大量的事件流有保持高吞吐量，比如日志聚合。

需要优雅的处理大数据的积压，以便支持离线系统数据的定期加载。

同时需要低延时，以便支撑传统的消息队列的应用场景。

我们希望支持分区的/分布式的/实时的流处理去创建新的继承流。这个驱动我们的分区（partitioning）和消费者（consumer）模型。

最终数据流被发送到其他的数据系统服务。系统应该能够容错，当出现机器失败的过程中。

为了支持这些用例导致我们设计一些独一无二的组件，相比传统的消息队列更像是数据库的日志系统。我们将在下面的章节指出设计元素。

### 存储

**不要担心文件系统!**

kafka严重依赖文件系统存储和缓存消息。通常有一个"磁盘很慢"的意识，人们对使用文件系统作为持久化结构持怀疑态度。事实上磁盘要比人们期待的慢得多或快得多，这取决于使用方式；好的磁盘设计的存储结构可以像网络一样快。

过去十年关于磁盘性能的事实是硬盘驱动的吞吐量和磁盘寻址延迟之间的巨大差异。在配置7200转，SATA RAID-5 array的一堆磁盘[JBOD](https://en.wikipedia.org/wiki/Non-RAID_drive_architectures)的写入为600M/s而随机写的速率为100k/s，相差6000倍。在所有的模式中这些线性的读写是最容易预测的，同时被操作系统很好的优化了。现代的操作系统提供预读(read-ahead)和后写(write-behind)技术，以要读去的大小的倍数来读取数据，激昂小块的写组成一个大块的写写入磁盘。这个问题的进一步讨论可以在[ACM Queue article](http://queue.acm.org/detail.cfm?id=1563874)中找到，他们实际上发现来这片文章，某种情况下顺序的硬盘访问设置比随机的内存访问更快[sequential disk access can in some cases be faster than random memory access!](http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg)

为了弥补性能差异，现代操作系统在使用主存作为硬盘缓存的时候表现的很激进。一个现代的操作系统会很高兴将所有的可用内存转移为硬盘的缓存，当然当内存被声明使用时这会伴随少量的额外性能损失。所有的硬盘的读写都会通过这个统一的缓存。除非使用直接IO(dirct I/O)，否则这个特性很难关闭，即使进程内部缓存了一份数据，这份数据仍然会被操作系统重复缓存在页缓存中。有效的将所有的东西都缓存了两次。

此外，我们建立在JVM之上，接触过java内存使用的人都知道的两点：

1) 对象的内存开销非常高，通常是对象大小的一倍(或者更糟)。
2) 随着堆内存的增加，java的gc变得越来越繁琐和缓慢。

基于以上事实，使用文件系统以及依靠页缓存要优于维持一个内存缓存或其他结构-直接使用内存的方式会直接导致两倍的可用存储，如果要存储一个压缩的对象可能又会导致缓存加倍。这样做在没有gc惩罚的情况下32G的机器会缓存到28-30G。另外即使服务重启，缓存还是热的，然而进程内缓存需要在内存中重建(10G缓存可能需要10分钟)或者完全冷启动(意味着糟糕的初始化性能)。这也极大的简化了代码，因为用于维护缓存和文件系统之间一致性的所有逻辑现在都在操作系统中，这往往比一次性的进程内尝试更有效、更正确。如果你的磁盘使用偏好线性读取，那么预读实际上就是在每次磁盘读取时使用有用的数据预先填充此缓存。

这暗示了一种非常简单的设计: 相比起来尽可能多的在内存中缓存并刷新到文件系统导致可能的用尽内存的恐慌，我们反着来。所有数据立刻写到文件系统上的持久化日志，不必刷新到磁盘。实际上这只意味着传送到内核的页缓存。

这种以页面缓存为中心的设计在[这篇文章](http://varnish-cache.org/wiki/ArchitectNotes)中有描述。

**恒定时间**

使用在消息系统中的持久化数据结构通常是每个消费者队列伴随一个BTree或其他一般意义上的随机存储结构来保持消息的元数据。BTree是普适性最好的可用数据结构，在消息系统中可以支持事务的或非事务的多种情况。他们确实有相当高的成本，尽管BTree的操作是O(logN)。一般情况下O(logN)基本等同于常数时间，但是对于磁盘操作来说并不是这样。磁盘寻道10ms一次弹出，每个磁盘在一个时间只能进行一次寻道，所以并发是受限的。因此即便一次小的磁盘寻道也会导致很高的开销。存储系统混合了很快的缓存操作和很慢的物理磁盘操作，随着固定缓存的数据增长，可以观测到的树形结构的性能通常是超线性的。

直观的可以类似日志系统的方式建立在简单的读和追加文件上。这个结构的优势在于所有的操作都是O(1)的，且读写不会相互影响。这将有明显的效率改进，由于影响效率的操作完全和数据大小解藕了。服务可以完全发挥便宜/低转速1+TB SATA的驱动。即便他们有低效的寻道效率，这些驱动有大块读写的可接受的性能，且价格只是1/3容量是3倍。

在没有效率损失的情况下接入无限制的虚拟统一磁盘，意味着我们可以提供一些常规消息系统通常找不到的特性。例如，在kafka中当消息被消费后我们可以不删除消息，可以保留相对来说长一点的时间(比如一个星期)。像我们描述的那样，这可以使消费者有极大的灵活性。


